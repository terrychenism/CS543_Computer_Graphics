void display()
{
	glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );     // clear the window

	//drawGrass();

	if (keyboardState == 3){	
		 glutSwapBuffers();
	}

	//----light source for shadow --------------
	float light[3]={-50,100,-30};//location of light 
	mat4 m;
	m[3][1]=-1.0/light[1];
	m[3][3] = 0;
	//--------------------------------------

	mat4 viewMat = LookAt( vec4(0,30,100,1), vec4(0,0,0,1), vec4(0,1,0,0) );
	Angel::mat4 perspectiveMat = Angel::Perspective((GLfloat)60.0, (GLfloat)width/(GLfloat)height, (GLfloat)0.1, (GLfloat) 9998.0);
	mat4 modelMat;
	ztrans = sqrt(pow(picture[numclick].xMAX-picture[numclick].xMIN,2)+pow(picture[numclick].yMAX-picture[numclick].yMIN,2)+pow(picture[numclick].zMAX-picture[numclick].zMIN,2));
	
	 
	mat4 viewMat_Tree = viewMat;
	mat4 viewMat_Plane = viewMat;
	mat4 viewMat_Car = viewMat;

	mat4 modelMatCar = modelMat;
	mat4 modelMatPlane = modelMat;
	mat4 modelMatGround = modelMat;

	

	//--------------------------------------------------
	if(keyboardState == 0)
	{
		element[iTreeNum].currentposition.x = 0;
		element[iTreeNum].currentposition.y = -10;
		element[iTreeNum].currentposition.z = 0;
		generatelinetree(iTreeNum);

		
				for(int i = 0; i < element[iTreeNum].count; i++ )
						{	
						
					
								modelMat = Angel::Translate(0,0,-ztrans ) ;

								modelMat = element[iTreeNum].rotateMat[i] * modelMat;
					
								modelMat = Angel::Translate(element[iTreeNum].PointoDraw[i].x,element[iTreeNum].PointoDraw[i].y,element[iTreeNum].PointoDraw[i].z) * modelMat;
					
								 //set up projection matricies
								mat4 m = viewMat * modelMat;
								GLuint modelMatrix = glGetUniformLocationARB(program, "model_matrix");
								glUniformMatrix4fv( modelMatrix, 1, GL_TRUE, m );
								drawpic(0);
								drawpic(1);
							

						}	
				
			}	
	else if (keyboardState == 3){
		iTreeNum=int(random(0,4));
		iColor.x =  float(random(0,1));
		iColor.y =  float(random(0,1));
		iColor.z =  float(random(0,1));
		element[iTreeNum].currentposition.x = randomPoint(-50.0f,50.0f).x;
		element[iTreeNum].currentposition.y = randomPoint(-200.0f,200.0f).y;
		element[iTreeNum].currentposition.z = randomPoint(-50.0f,50.0f).z;
		generatelinetree(iTreeNum);

						for(int i = 0; i < element[iTreeNum].count; i++ )
						{	
						
					
								modelMat = Angel::Translate(0,0,-ztrans ) ;

								modelMat = element[iTreeNum].rotateMat[i] * modelMat;
					
								modelMat = Angel::Translate(element[iTreeNum].PointoDraw[i].x,element[iTreeNum].PointoDraw[i].y,element[iTreeNum].PointoDraw[i].z) * modelMat;

								viewMat_Tree  = viewMat_Tree* Translate(light[0],light[1], light[2])*m*Translate(-light[0],-light[1],-light[2]); 

								// set up projection matricies
								mat4 m = viewMat_Tree * modelMat;
								GLuint modelMatrix = glGetUniformLocationARB(program, "model_matrix");
								glUniformMatrix4fv( modelMatrix, 1, GL_TRUE, m );
								drawpic(0);
								drawpic(1);
							

						}	
	modelMatGround= Angel::Scale(5,5,5)*modelMatGround; 
	mat4 m2 = viewMat * modelMatGround;
	GLuint modelMatrixGround = glGetUniformLocationARB(program, "model_matrix");
	glUniformMatrix4fv( modelMatrixGround, 1, GL_TRUE, m2 );	
	//drawGround();
	init();
	}

	else if (keyboardState == 1){

			int count=0;
			for (int i = 1; i <= 2; i++)
			{

				count++;
				cout<<count<<endl;


			
				iTreeNum=int(random(0,4));
				iColor.x =  float(random(0,1));
				iColor.y =  float(random(0,1));
				iColor.z =  float(random(0,1));

	
				switch (iTreeNum){
					case 0:
						element[iTreeNum].currentposition.x = randomPoint(-1000.0f,1000.0f).x;
						element[iTreeNum].currentposition.y = randomPoint(-200.0f,200.0f).y;
						element[iTreeNum].currentposition.z = randomPoint(-50.0f,50.0f).z;
						break;
					case 1:
						element[iTreeNum].currentposition.x = randomPoint(-1000.0f,0.0f).x;
						element[iTreeNum].currentposition.y = randomPoint(-200.0f,200.0f).y;
						element[iTreeNum].currentposition.z = randomPoint(-50.0f,50.0f).z;
						break;
					case 2:
						element[iTreeNum].currentposition.x = randomPoint(-50.0f,10.0f).x;
						element[iTreeNum].currentposition.y = randomPoint(-200.0f,200.0f).y;
						element[iTreeNum].currentposition.z = randomPoint(-50.0f,50.0f).z;
						break;
					case 3:
						element[iTreeNum].currentposition.x = randomPoint(-150.0f,10.0f).x;
						element[iTreeNum].currentposition.y = randomPoint(-200.0f,200.0f).y;
						element[iTreeNum].currentposition.z = randomPoint(-50.0f,50.0f).z;
						break;
					case 4:
						element[iTreeNum].currentposition.x = randomPoint(-300.0f,10.0f).x;
						element[iTreeNum].currentposition.y = randomPoint(-200.0f,200.0f).y;
						element[iTreeNum].currentposition.z = randomPoint(-50.0f,50.0f).z;
						break;
					}
				
				generatelinetree(iTreeNum);

		
				for(int i = 0; i < element[iTreeNum].count; i++ )
						{	
						
					
								modelMat = Angel::Translate(0,0,-ztrans ) ;

								modelMat = element[iTreeNum].rotateMat[i] * modelMat;
					
								modelMat = Angel::Translate(element[iTreeNum].PointoDraw[i].x,element[iTreeNum].PointoDraw[i].y,element[iTreeNum].PointoDraw[i].z) * modelMat;
	
								 //set up projection matricies
								mat4 m = viewMat * modelMat;
								GLuint modelMatrix = glGetUniformLocationARB(program, "model_matrix");
								glUniformMatrix4fv( modelMatrix, 1, GL_TRUE, m );
								drawpic(0);
								drawpic(1);
							

						}	
				
			}	

	//----------create shadow --------------------------
	//float light[3]={-50,-50,50};//location of light 
	//mat4 m;
	//m[3][1]=-1.0/light[1];
	//m[3][3] = 0;
	//mat4 mm = modelMatShadow*Translate(light[0],light[1], light[2])*m*Translate(-light[0],-light[1],-light[2]); 
	
	//GLuint modelMatrixShadow = glGetUniformLocationARB(program, "model_matrix");
	//glUniformMatrix4fv( modelMatrixShadow, 1, GL_TRUE, mm );	

	//----------------------------------------------------

	//-----draw car-------------
	modelMatCar = modelMatCar* Angel::Scale(2,2,2)*Angel::RotateX(-10.0f)* Angel::Translate(20,0,0);
	mat4 m1 = viewMat * modelMatCar;
	GLuint modelMatrixCar = glGetUniformLocationARB(program, "model_matrix");
	glUniformMatrix4fv( modelMatrixCar, 1, GL_TRUE, m1 );	
	drawpic(2);

	//------draw car shadow------
	viewMat_Car  = viewMat_Car * Translate(light[0],light[1], light[2])*m*Translate(-light[0],-light[1],-light[2]); 
	mat4 mm1 = viewMat_Car * modelMatCar;
	GLuint modelMatrixShadow1 = glGetUniformLocationARB(program, "model_matrix");
	glUniformMatrix4fv( modelMatrixShadow1, 1, GL_TRUE, mm1 );	
	drawpic(2);

	//------draw plane-------
	modelMatPlane = modelMatPlane* Angel::Scale(2,2,2)*Angel::RotateX(15.0f)* Angel::Translate(-10,20,0);
	mat4 m3= viewMat * modelMatPlane;
	GLuint modelMatrixPlane = glGetUniformLocationARB(program, "model_matrix");
	glUniformMatrix4fv( modelMatrixPlane, 1, GL_TRUE, m3 );	
	drawpic(3);

	//------draw plane shadow------
	viewMat_Plane = viewMat_Plane* Translate(light[0],light[1], light[2])*m*Translate(-light[0],-light[1],-light[2]); 
	mat4 mm2 = viewMat_Plane * modelMatPlane;
	GLuint modelMatrixShadow2 = glGetUniformLocationARB(program, "model_matrix");
	glUniformMatrix4fv( modelMatrixShadow2, 1, GL_TRUE, mm2 );	
	drawpic(3);
	//---------------------

	//------draw ground-------
	modelMatGround= Angel::Scale(5,5,5)*modelMatGround; 
	mat4 m2 = viewMat * modelMatGround;
	GLuint modelMatrixGround = glGetUniformLocationARB(program, "model_matrix");
	glUniformMatrix4fv( modelMatrixGround, 1, GL_TRUE, m2 );	
	//drawGround();
	init();
	}
	//-------------------------

	GLuint projectionMatrix = glGetUniformLocationARB(program, "projection_matrix");
	glUniformMatrix4fv( projectionMatrix, 1, GL_TRUE, perspectiveMat);
	
	

	glFlush(); // force output to graphics hardware

	 //use this call to double buffer
	glutSwapBuffers();
//	 you can implement your own buffers with textures
}
