// Starter program for HW 0. 
// Program draws a triangle. Study the program first
// Then modify the function generateGeometry to draw a two-Dimensional Sierpinski Gasket       
// Generated using randomly selected vertices and bisection

// Angel.h is homegrown include file that also includes glew and freeglut

#include "Angel.h"
#include<time.h>


//----------------------------------------------------------------------------

// remember to prototype
//void generateGeometry( void );
void initGPUBuffers( void );
void shaderSetup( void );
void display( void );
void keyboard( unsigned char key, int x, int y );
void myMouse(int button, int state, int x, int y);
void drawGingerman(void);
void randomchoose(void);
void drawdots(int i);
void drawthumbnails(void);
typedef vec2 point2;

using namespace std;
const int screenWidth = 640;
const int screenHeight = 480;
int keyboard_value='p';
// Array for polyline
point2 points[99999];
point2 points2[200];
point2 points3[200];
GLuint program;
GLuint buffer;
struct GLintPoint{
	GLint x,y;
}; 
int corner_x=0;
int corner_y=432;
int dotsnum=0; 
int dotsnum2=0; 



void initGPUBuffers( void )
{
	    // Create a vertex array object
    GLuint vao;
    glGenVertexArrays( 1, &vao );
    glBindVertexArray( vao );

    
    glGenBuffers( 1, &buffer );
    glBindBuffer( GL_ARRAY_BUFFER, buffer );
    glBufferData( GL_ARRAY_BUFFER, sizeof(points), points, GL_STATIC_DRAW );


}


void shaderSetup( void )
{
	    // Load shaders and use the resulting shader program
    program = InitShader( "vshader1.glsl", "fshader1.glsl" );
    glUseProgram( program );

    // Initialize the vertex position attribute from the vertex shader
    GLuint loc = glGetAttribLocation( program, "vPosition" );
    glEnableVertexAttribArray( loc );
    glVertexAttribPointer( loc, 2, GL_FLOAT, GL_FALSE, 0,
                           BUFFER_OFFSET(0) );

	// sets the default color to clear screen
    glClearColor( 1.0, 1.0, 1.0, 1.0 ); // white background

}



void setWindow(GLdouble left,GLdouble right,GLdouble bottom,GLdouble top)
{   
	mat4 ortho = Ortho2D( left,right,bottom,top );
	GLint ProjLoc = glGetUniformLocation( program, "Proj" );
	glUniformMatrix4fv( ProjLoc, 1, GL_FALSE, ortho );
}


//------------------------------------------------------
void drawPolylineFile(char *FileName)
{
	
	char line[256];
	float left, right, bottom, top;
	FILE *inStream;
	GLint numpolys, numLines; 
	GLfloat	x, y;
	int NumPoints;

	if((inStream = fopen(FileName, "rt")) == NULL) // Open The File
	{
		printf("File does not exist!");
		exit(0);
	}

	//Deal with dino.dat file
	if(strcmp(FileName,"dino.dat")==0)
	{
		left = 0;
		right = 640;
		bottom = 0;
		top = 480;
	}
	else 
	{
		while(!feof(inStream))
		{
			//Just go through comments
			memset(line, 0, 256);
			fscanf(inStream, "%s", line);
			if(line[0] == '*')
				break;
			else
				continue;
		}
		// read in the four directions of extents
		fscanf(inStream, "%f %f %f %f\n", &left, &top, &right, &bottom);
	 }
	

	fscanf(inStream,"%d", &numpolys);			// read the number of polylines
	for(int j = 0; j < numpolys; j++)
	{	//read each polyline
		
		fscanf(inStream,"%d", &numLines);
		for (int i = 0; i < numLines; i++)
		{
			fscanf(inStream,"%f %f", &x, &y);
			points[i] = point2( x , y);
		}
		NumPoints = numLines;
		setWindow(left, right, bottom,top);
		glBufferData( GL_ARRAY_BUFFER, sizeof(points), points, GL_STATIC_DRAW );
		glDrawArrays( GL_LINE_STRIP, 0, NumPoints ); 
		//glFlush();
	}

	fclose(inStream);
}



//void myMovedMouse(GLint x, GLint y)
//{
//CP.x = x; CP.y = y; // update the CP
//}

//----------------------------------------------------------------------------
// this is where the drawing should happen
//----------------------------------------------------------------------------
//keyboard handler
void keyboard( unsigned char key, int x, int y )
{
    switch ( key ) {
    case 033:
        exit( EXIT_SUCCESS );
        break;
	case 'p':
		keyboard_value='p';
		//display();
		break;
	case 'e':
		glClear(GL_COLOR_BUFFER_BIT);//clear screen
		keyboard_value='e';
		
		break;
	case 'k':
		//drawHouse();
		keyboard_value='k';
		break;
	case 'g':
		keyboard_value='g';
		//glClear(GL_COLOR_BUFFER_BIT);
		glViewport(0, 0, 640, 480);
		drawGingerman();
		//display();
		break;

	case 'b':
		keyboard_value='b';
		break;

	case 'd': 
		//drawHouse();
		keyboard_value='d';
		break;
	case 'm': 
		keyboard_value='m';
		break;
	case 't': 
		//randomchoose();	
		
		keyboard_value='t';
		display();
		break;
    }
}
//----------------------------------------------------------------------------
// mouse handler

void myMouse(int button, int state, int x, int y)
{
static GLintPoint corner[2];
static int numCorners = 0; // initial value is 0

switch(keyboard_value){
case'p':
	if(button == GLUT_LEFT_BUTTON && state == GLUT_DOWN)
	{
	corner_x = x;
	corner_y= screenHeight - y; //flip y coord
	}
	break;
case't':

	break;

case'e':
	if(button == GLUT_LEFT_BUTTON && state == GLUT_DOWN){
		
			corner_x = x;
			corner_y = screenHeight - y; //flip y coord
			points2[dotsnum]= point2( corner_x , corner_y);
			dotsnum++;
	}
	break;
			
case'b':
	if(button == GLUT_LEFT_BUTTON && state == GLUT_DOWN){
		
			corner_x = x;
			corner_y = screenHeight - y; //flip y coord
			points3[dotsnum2]= point2( corner_x , corner_y);
			dotsnum2++;
	}	
	break;
	
			
		
		
			/*glViewport(0, 0, 640, 480);
			setWindow(0, 640, 0,480);
		
			glBufferData( GL_ARRAY_BUFFER, sizeof(points), points, GL_STATIC_DRAW );
			glDrawArrays( GL_LINE_STRIP, 0, 2); */
			
			//glFlush();
	
	
}
}


//------------------------------------------------------
//draw 10 ployline
void  drawthumbnails(void){
	glViewport(0, 432, 64, 48);
	drawPolylineFile("dino.dat");
	glViewport(64, 432, 64, 48);
	drawPolylineFile("birdhead.dat");
	glViewport(64*2, 432, 64, 48);
	drawPolylineFile("dragon.dat");
	glViewport(64*3, 432, 64, 48);
	drawPolylineFile("house.dat");
	glViewport(64*4, 432, 64, 48);
	drawPolylineFile("knight.dat");
	glViewport(64*5, 432, 64, 48);
	drawPolylineFile("rex.dat");
	glViewport(64*6, 432, 64, 48);
	drawPolylineFile("scene.dat");
	glViewport(64*7, 432, 64, 48);
	drawPolylineFile("usa.dat");
	glViewport(64*8, 432, 64, 48);
	drawPolylineFile("vinci.dat");
	glViewport(64*9, 432, 64, 48);
	drawPolylineFile("vinci.dat");
}

//-------------------------------------------------------
void display( void )
{
	

    //glClear( GL_COLOR_BUFFER_BIT );     // clear the window


	switch(keyboard_value)
	{
	case 'p':
		glClear( GL_COLOR_BUFFER_BIT ); 
		drawthumbnails();
		if((corner_x <=64)&&(corner_x >=0)&&corner_y>=432){
			glViewport(0, 0, 640, 432);
			drawPolylineFile("dino.dat");
		}
		else if (corner_x <=64*2&&corner_x >64&&corner_y>=432){
		glViewport(0, 0, 640, 432);
		drawPolylineFile("birdhead.dat");
		}
		else if(corner_x <=64*3&&corner_x >64*2&&corner_y>=432){
			glViewport(0, 0, 640, 432);
			drawPolylineFile("dragon.dat");
		}
		else if(corner_x <=64*4&&corner_x >64*3&&corner_y>=432){
			glViewport(0, 0, 640, 432);
			drawPolylineFile("house.dat");
		}
		else if(corner_x <=64*5&&corner_x >64*4&&corner_y>=432){
			glViewport(0, 0, 640, 432);
			drawPolylineFile("knight.dat");
		}
		else if(corner_x <=64*6&&corner_x >64*5&&corner_y>=432){
			glViewport(0, 0, 640, 432);
			drawPolylineFile("rex.dat");
		}
		else if(corner_x <=64*7&&corner_x >64*6&&corner_y>=432){
			glViewport(0, 0, 640, 432);
			drawPolylineFile("scene.dat");
		}
		else if(corner_x <=64*8&&corner_x >64*7&&corner_y>=432){
			glViewport(0, 0, 640, 432);
			drawPolylineFile("usa.dat");
		}
		else if(corner_x >64*8 && corner_y>=432){
			glViewport(0, 0, 640, 432);
			drawPolylineFile("vinci.dat");
		}

			break;



	case 't':
	glClear( GL_COLOR_BUFFER_BIT ); 
	drawthumbnails();
	randomchoose();	
	
			break;

	/*case 'e':
		
		break;*/

	case 'g': 
	
		glViewport(0, 0, 640, 480);
		drawGingerman();
	
	break;

	case 'e': 
			drawthumbnails();
			setWindow(0, 640, 0,480);
			glViewport(0, 0, 640, 480);
			glBufferData( GL_ARRAY_BUFFER, sizeof(points2), points2, GL_STATIC_DRAW );
			glDrawArrays( GL_LINE_STRIP, 0, dotsnum); 
	break;

	case 'b': 
			setWindow(0, 640, 0,480);
			glViewport(0, 0, 640, 480);
			glBufferData( GL_ARRAY_BUFFER, sizeof(points3), points3, GL_STATIC_DRAW );
			glDrawArrays( GL_LINE_STRIP, 0, dotsnum2); 
	break;
}
	

    glFlush(); // force output to graphics hardware

	
	//glutPostRedisplay();
}
//----------------------------------------------------------------
//randomly choose the pic to draw in 6*6
void randomchoose(void)
{

	srand((int)time(0));

	for(int i=0;i<36;i++){
	glViewport(107*int(i/6), 72*(i%6), 107, 72);
	
		 int randnum=rand()%10+1;
		 switch(randnum){
	case 1:
	drawPolylineFile("dino.dat");
	break;
	case 2:
	drawPolylineFile("birdhead.dat");
	break;
	case 3:
	drawPolylineFile("dragon.dat");
	break;
	case 4:
	drawPolylineFile("house.dat");
	break;
	case 5:
	drawPolylineFile("knight.dat");
	break;
	case 6:
	drawPolylineFile("rex.dat");
	break;
	case 7:
	drawPolylineFile("scene.dat");
	break;
	case 8:
	drawPolylineFile("usa.dat");
	break;
	case 9:
	drawPolylineFile("vinci.dat");
	break;
	case 10:
	drawPolylineFile("vinci.dat");
	break;
		}
	}
}


//----------------------------------------------------------------------------
// draw Gingerman

void drawGingerman(void) {
   
  // values used in fractal algorithm
  // next values are a function of prev values
  int nextX, nextY;

  int prevX = 115;
  int prevY = 121;
  points[0]=point2( prevX , prevY);
  int M = 40;
  int L = 3;	
  int pointnum; 
  glClear(GL_COLOR_BUFFER_BIT);//clear

    // "Gingerbread Man" algorithm
    // q.x = M(1 + 2L) - p.y + |p.x - LM|
    // q.y = p.x
    // where p is previous point, and q is the current point
    // L and M are constants for scaling and positioning
  

	  for(int j = 0; j < 50000; j++){

		// calculate next points to plot  
        nextX = ( (M*(1+2*L)) - prevY + (abs(prevX - (L*M)))  );
        nextY = prevX;
		points[j]= point2( nextX , nextY);
		
        
		// set current point as old point
		prevX = nextX;
        prevY = nextY;
		pointnum = j;

	  }


    
	setWindow(0, 640, 0,480);
	glBufferData( GL_ARRAY_BUFFER, sizeof(points), points, GL_STATIC_DRAW );
	glDrawArrays( GL_POINTS, 0, pointnum ); 
	glFlush();
}




//----------------------------------------------------------------------------
// entry point
int main( int argc, char **argv )
{
	// init glut
    glutInit( &argc, argv );
    glutInitDisplayMode( GLUT_RGBA | GLUT_SINGLE );
    glutInitWindowSize( 640, 480 );

    // If you are using freeglut, the next two lines will check if 
    // the code is truly 3.2. Otherwise, comment them out
    
    //glutInitContextVersion( 3, 3 );
    //glutInitContextProfile( GLUT_CORE_PROFILE );

	// create GLUT window for drawing
    glutCreateWindow( "Starting App" );

	// init glew
    glewInit();

    //generateGeometry( );
    initGPUBuffers( );
    shaderSetup( );

	// assign handlers
    glutDisplayFunc( display );
    glutKeyboardFunc( keyboard );
	// should add menus
	// add mouse handler
	glutMouseFunc(myMouse);
	// add resize window functionality (should probably try to preserve aspect ratio)

	// enter the drawing loop
	// frame rate can be controlled with 
    glutMainLoop();
    return 0;

}
