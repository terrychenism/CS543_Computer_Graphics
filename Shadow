void shadow()
{
	// Viewing transformation parameters

	GLfloat radius = 1.0;
	GLfloat theta = 0.0;
	GLfloat phi = 0.0;

	const GLfloat  dr = 5.0 * DegreesToRadians;

	mat4  model_view;  // model-view matrix uniform shader variable location

	// Projection transformation parameters

	GLfloat  left = -1.0, right = 1.0;
	GLfloat  bottom = -1.0, top = 1.0;
	GLfloat  zNear = 0.5, zFar = 3.0;

	mat4  projection; // projection matrix uniform shader variable location



	float light[3];//locationoflight 
	mat4 m; //shadowprojectionmatrixinitiallyanidentitymatrix 
	m[3][1]=-1.0/light[1];

	point4 square[4]={vec4(-0.5,0.5,-0.5,1.0),vec4(-0.5,0.5,0.5,1.0), vec4(0.5,0.5,-0.5,1.0),vec4(0.5,0.5,0.5,1.0)}; 


	GLuint abuffer,buffer; 
	glGenVertexArrays(1,&abuffer); 
	glBindVertexArray(abuffer); 
	int loc=glGetAttribLocation(program,"vPosition"); 
	glEnableVertexAttribArray(loc); 
	glVertexAttribPointer(loc,4,GL_FLOAT,GL_FALSE,0, BUFFER_OFFSET(0)); 
	GLuint color_loc=glGetUniformLocation(program,"fcolor");
	glGenBuffers(1,&buffer); 
	glBindBuffer(GL_ARRAY_BUFFER,buffer); 
	glBufferData(GL_ARRAY_BUFFER,sizeof(square),square, GL_STATIC_DRAW); 

	point4  eye( radius*sin(theta)*cos(phi),
		 radius*sin(theta)*sin(phi),
		 radius*cos(theta),
		 1.0 );
    point4  at( 0.0, 0.0, 0.0, 1.0 );
    vec4    up( 0.0, 1.0, 0.0, 0.0 );
	model_view = LookAt(eye,at,up); 
	projection = Ortho(left,right,bottom,top,near,far); 
	GLuint matrix_loc,projection_loc;
	glUniformMatrix4fv(matrix_loc,1,GL_TRUE,model_view); 
	glUniformMatrix4fv(projection_loc,1,GL_TRUE,projection); 


	mat4 mm; //clearthewindow 
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); //renderredsquare 
	glUniform4fv(color_loc,1,red); 
	glDrawArrays(GL_TRIANGLE_STRIP,0,4); //matrixtocomputeverticesofshadowpolygon 
	mm=model_view*Translate(light[0],light[1], light[2])*m*Translate(-light[0],-light[1],-light[2]); 
	glUniformMatrix4fv(matrix_loc,1,GL_TRUE,mm); //rendershadowpolygon 
	glUniform4fv(color_loc,1,black); 
	glDrawArrays(GL_TRIANGLE_STRIP,0,4); 
	glutSwapBuffers();

}
