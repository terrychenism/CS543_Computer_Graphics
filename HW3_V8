// Two-Dimensional Sierpinski Gasket       
// Generated using randomly selected vertices and bisection

#include "Angel.h"
#include "math.h"
#include <cassert>
#include "math.h"
#include <ctime>
#include <cstdlib>
#include <vector>

using namespace std;
//----------------------------------------------------------------------------
int width = 0;
int height = 0;
int keyboard_value='W';
float ztrans;
bool Xaction=true;
bool xaction=true;
bool Yaction=true;
bool yaction=true;
bool Zaction=true;
bool zaction=true;
bool rotateaction=true;
bool scaleaction=true;
bool normalaction=true;
bool boundaction=true;
bool pulsingaction=true;
int numclick=0;
int Lsysnum=0;


float stepX=0,stepY=0,stepZ=0;
// remember to prototype
void generateGeometry( void );
void display( void );
void keyboard( unsigned char key, int x, int y );
void quad( int a, int b, int c, int d );
void colorcube(void);
void drawCube(void);
void ReadPlyFile(char *FileName,int i);
void idle( void );
void doIterate(int num,int iteratenum);
void generatelinetree( void );

typedef Angel::vec4  color4;
typedef Angel::vec4  point4;
typedef Angel::vec3  point3;
vec4 currentposition=(0,0,0,1);
vec4 pointodraw[9999];
mat4 pointodir[9999];
vec4 PointoDraw[5000];
mat4 rotateMat[5000];
// handle to program
GLuint program;

using namespace std;

//const int NumVertices = 36; //(6 faces)(2 triangles/face)(3 vertices/triangle)
//point4 points[NumVertices];
//color4 colors[NumVertices];

class vertexdata
{
public:
		int numvertex;
		int numface; 
		int* Faces_Triangles;
		float* Vertex_Buffer;
		float* Normals;
		GLfloat* currentNormal;
		GLuint m_VBO;
		GLuint n_VBO;
		GLuint m_IBO;
		GLuint n_IBO;
		GLfloat xMAX,xMIN,yMAX,yMIN,zMAX,zMIN;
		float stepN;
		float thetaY;
		float vr[3];

	vertexdata()
	{
		xMAX=0;
		xMIN=0;
		yMAX=0;
		yMIN=0;
		zMAX=0;
		zMIN=0;
		stepN=0;
		thetaY=0;

	}

	~vertexdata()
	{
		delete Faces_Triangles;
		delete Vertex_Buffer;
		delete Normals;
		delete currentNormal;
		
	}

};

vertexdata picture[2];

class token
{
	public:		
		int len,iter;
		GLfloat	rotx, roty, rotz;
		char start;
		char leftstart[40];
		char* rightsystem;
		char* leftsystem;
		int initlength;
		int length;
		int count;
		size_t s;
	token()
	{
		initlength=0;
		length=0;
		count= 0;
		s=0;
	}
	~token()
	{
		delete rightsystem;
		delete leftsystem;
	}

};
token element[5];

class Lsystem
{
	public:
		mat4 tranX;
		mat4 tranY;
		mat4 tranZ;
		mat4 rotateX;
		mat4 rotateY;
		mat4 rotateZ;
};
Lsystem lsys[50];

void colorcube()
{

	float boundpoints[24]={ picture[numclick].xMIN, picture[numclick].yMIN,  picture[numclick].zMAX ,
						    picture[numclick].xMIN, picture[numclick].yMAX,  picture[numclick].zMAX ,
							picture[numclick].xMAX, picture[numclick].yMAX, picture[numclick].zMAX ,
							picture[numclick].xMAX, picture[numclick].yMIN, picture[numclick].zMAX ,
							picture[numclick].xMIN, picture[numclick].yMIN,  picture[numclick].zMIN,
							picture[numclick].xMIN,  picture[numclick].yMAX, picture[numclick].zMIN ,
							picture[numclick].xMAX,  picture[numclick].yMAX, picture[numclick].zMIN ,
							picture[numclick].xMAX,  picture[numclick].yMIN, picture[numclick].zMIN ,
							};

	unsigned int indices[24] = {1,5,6,2,
								1,2,3,0,
								7,4,0,3,
								5,4,7,6,
								2,6,7,3,
								1,0,4,5
	};


		glGenBuffers( 1, &picture[numclick].n_VBO );
		glBindBuffer( GL_ARRAY_BUFFER, picture[numclick].n_VBO );
		glBufferData( GL_ARRAY_BUFFER, sizeof(float)*24, boundpoints, GL_STATIC_DRAW );

		//create IBO
		glGenBuffers( 1, &picture[numclick].n_IBO );
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,  picture[numclick].n_IBO );
		glBufferData( GL_ELEMENT_ARRAY_BUFFER,  sizeof(int)*24, indices, GL_STATIC_DRAW );


}

void drawnormal(){

	GLuint buffer1;
    glGenBuffers( 1, &buffer1 );
    glBindBuffer( GL_ARRAY_BUFFER, buffer1 );
	//glBindBuffer( GL_ARRAY_BUFFER, picture[numclick].m_VBO );
    glBufferData( GL_ARRAY_BUFFER, sizeof(float)*picture[numclick].numface*6, picture[numclick].Normals, GL_STATIC_DRAW );
	glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
	glEnable( GL_DEPTH_TEST );


	GLuint vPosition = glGetAttribLocation( program, "vPosition" );
	glEnableVertexAttribArray( vPosition );
	glVertexAttribPointer( vPosition, 3, GL_FLOAT, GL_FALSE, 0,
			   BUFFER_OFFSET(0) );
	//glDrawElements(  GL_LINE_STRIP, picture[numclick].numface*6, GL_UNSIGNED_INT,  0);
    glDrawArrays( GL_LINES, 0, picture[numclick].numface*6  );
	glDisable( GL_DEPTH_TEST ); 

	 }	

vec4 randomPoint( float min, float max)
{
        Angel::vec4 point(0, 0, 0, 1);
    double random(double,double);
    srand(unsigned(time(0)));
    
        
                point.x = GLfloat(random(min,max));
				point.y = GLfloat(random(min,max));
                point.z = GLfloat(random(min,max));       
        
     return point;
}
double random(double start, double end)
{ 
        return start+(end-start)*rand()/(RAND_MAX);
}



GLuint vao;
void generateGeometry( void )
{	
	//colorcube();

	// Load shaders and use the resulting shader program
    program = InitShader( "vshader1.glsl", "fshader1.glsl" );
    glUseProgram( program );

    glGenVertexArrays( 1, &vao );
    glBindVertexArray( vao );



     // set up vertex arrays
    GLuint vPosition = glGetAttribLocation( program, "vPosition" );
    glEnableVertexAttribArray( vPosition );
    glVertexAttribPointer( vPosition, 3, GL_FLOAT, GL_FALSE, 0,
			   BUFFER_OFFSET(0) );

    glClearColor( 0.0, 0.0, 0.0, 1.0 ); // black background
}

void drawCube(void)
{
	colorcube();
	glClearColor( 0.0, 0.0, 0.0, 1.0 ); // white background
	//glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
	glEnable( GL_DEPTH_TEST );
	//glBindBuffer( GL_ARRAY_BUFFER, picture[numclick].n_VBO );
	//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,  picture[numclick].n_IBO );
	GLuint vPosition = glGetAttribLocation( program, "vPosition" );
	glEnableVertexAttribArray( vPosition );
	glVertexAttribPointer( vPosition, 3, GL_FLOAT, GL_FALSE, 0,
			   BUFFER_OFFSET(0) );	
	//glDrawArrays( GL_QUADS, 0, 24 );
	glDrawElements( GL_QUADS, 24, GL_UNSIGNED_INT,  0);//violation
	glDisable( GL_DEPTH_TEST ); 
}

void drawpic(int i)
{


     //Create and initialize a buffer object
	
	// sets the default color to clear screen
    glClearColor( 0.0, 0.0, 0.0, 1.0 ); // white background

	// change to GL_FILL
	glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );

	glEnable( GL_DEPTH_TEST );
	glBindBuffer( GL_ARRAY_BUFFER, picture[i].m_VBO );
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,  picture[i].m_IBO );
	GLuint vPosition = glGetAttribLocation( program, "vPosition" );
	glEnableVertexAttribArray( vPosition );
	glVertexAttribPointer( vPosition, 3, GL_FLOAT, GL_FALSE, 0,
			   BUFFER_OFFSET(0) );

	GLuint vStep = glGetUniformLocation( program, "step" );

	glUniform1f(vStep, picture[numclick].stepN);

	GLuint vPulsing = glGetUniformLocation( program, "pulsing" );
	if(keyboard_value=='B'){
		glUniform1i(vPulsing, true);
	}
	else
	{
		glUniform1i(vPulsing, false);
	}

	GLuint vNormal = glGetUniformLocation( program, "face_normal" );
	for( int i = 0; i < picture[numclick].numface; i++ )
	{
		// 1 update current triangle normal
		//glUniform3fv(vNormal, 1, picture[numclick].currentNormal);
		glUniform3f(vNormal,  picture[numclick].currentNormal[3*i],picture[numclick].currentNormal[3*i+1],picture[numclick].currentNormal[3*i+2]);
		// 2 draw current tirangle face
		unsigned int offset = sizeof(unsigned int)*3*i;
		glDrawElements(  GL_TRIANGLES, 3, GL_UNSIGNED_INT,  (GLvoid*)offset);
	}

	//glDrawArrays( GL_TRIANGLES, 0, picture[0].numface*3 );
	//glDrawElements(  GL_TRIANGLES, picture[i].numface*3, GL_UNSIGNED_INT,  0);
	glDisable( GL_DEPTH_TEST ); 
}

void drawtree(int picnum)
{
	glClearColor( 0.0, 0.0, 0.0, 1.0 ); // white background
	glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
	glEnable( GL_DEPTH_TEST );
	glBindBuffer( GL_ARRAY_BUFFER, picture[picnum].m_VBO );
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,  picture[picnum].m_IBO );
	GLuint vPosition = glGetAttribLocation( program, "vPosition" );
	glEnableVertexAttribArray( vPosition );
	glVertexAttribPointer( vPosition, 3, GL_FLOAT, GL_FALSE, 0,
			   BUFFER_OFFSET(0) );
	glDrawElements( GL_TRIANGLES, picture[picnum].numface*3, GL_UNSIGNED_INT,  0);
	glDisable( GL_DEPTH_TEST ); 
}



void display( void )
{
	//Angel::mat4 mv = Angel::LookAt(vec4 eye, vec4 at, vec4 up); 
	mat4 viewMat = LookAt( vec4(0,0,200,1), vec4(0,0,0,1), vec4(0,1,0,0) );
	Angel::mat4 perspectiveMat = Angel::Perspective((GLfloat)60.0, (GLfloat)width/(GLfloat)height, (GLfloat)0.1, (GLfloat) 9998.0);
	mat4 modelMat;

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );     // clear the window
	for (Lsysnum = 0; Lsysnum < 5; Lsysnum++){
			for(int i = 0; i < element[Lsysnum].count; i++ )
			{	
					/*modelMat = modelMat *Angel::Translate(-(picture[numclick].xMAX + picture[numclick].xMIN)/2,-(picture[numclick].yMAX + picture[numclick].yMIN)/2,-(picture[numclick].zMAX + picture[numclick].zMIN)/2);
					*/
					//modelMat = modelMat * mv;
					//modelMat = modelMat * Angel::Translate(0.0, 0.0, -2.0f) * Angel::RotateY(45.0f) * Angel::RotateX(35.0f);
					

					ztrans = sqrt(pow(picture[numclick].xMAX-picture[numclick].xMIN,2)+pow(picture[numclick].yMAX-picture[numclick].yMIN,2)+pow(picture[numclick].zMAX-picture[numclick].zMIN,2));
					
					modelMat = Angel::Translate(0,0,-ztrans ) /** Angel::RotateY(picture[numclick].thetaY)*/ ;
			
					//modelMat = Angel::Translate(stepX,stepY,stepZ) * modelMat;

					//create matrix for rotate   vec4 PointoDraw[5000];mat4 rotateMat[5000];
					modelMat = rotateMat[i] * modelMat;
					
					modelMat = Angel::Translate(PointoDraw[i].x,PointoDraw[i].y,PointoDraw[i].z) * modelMat;
					
					drawtree(0);
					drawtree(1);
					
					//if(element[Lsysnum].leftsystem[i] == 'F')
						//{
							
							//modelMat =  pointodir[i]*  modelMat;
							//modelMat =  Angel::Translate(pointodraw[i].x,pointodraw[i].y,-pointodraw[i].z) * modelMat ;
							//drawtree(1);
	
					//	}


					// set up projection matricies
					mat4 m = viewMat * modelMat;
					GLuint modelMatrix = glGetUniformLocationARB(program, "model_matrix");
					glUniformMatrix4fv( modelMatrix, 1, GL_TRUE, m );
					GLuint projectionMatrix = glGetUniformLocationARB(program, "projection_matrix");
					glUniformMatrix4fv( projectionMatrix, 1, GL_TRUE, perspectiveMat);


					
					
					
					
					
			}
	}

	//drawpic(numclick);
	//drawCube();

	if(keyboard_value=='e')
	{	
		if(!boundaction){
		drawCube();
		}
		cout<<"bounding\n";
		
	}

	if(keyboard_value=='m')
	{
		if(!normalaction){
		drawnormal();

		}
		cout<<"normal\n";
	}
	if(keyboard_value=='B')
	{
		//if(!pulsingaction){
			
			//cout<<"pulsing \n";
		//}
		
		
	}

    glFlush(); // force output to graphics hardware

	// use this call to double buffer
	glutSwapBuffers();
	// you can implement your own buffers with textures
}



void keyboard( unsigned char key, int x, int y )
{
    switch ( key ) {
    case 033:
        exit( EXIT_SUCCESS );
        break;
	case 'W':
		keyboard_value='W';
		numclick=1; 
		stepX=0;
		stepY=0;
		stepZ=0;
		display();
		break;
	case 'N':
		stepX=0;
		stepY=0;
		stepZ=0;
		keyboard_value='N';
		numclick++; 
		if(numclick==2){
			numclick=0;
		}
		display();
		break;
	case 'P':
		keyboard_value='P';
		numclick--; 
		if(numclick==-1){
			numclick=1;
		}
		display();
		break;
	case 'X':
		if(keyboard_value=='R')
		{
			break;
		}
		keyboard_value='X';
		Xaction=!Xaction;
		idle();
		break;		
	case 'x':
		if(keyboard_value=='R')
		{
			break;
		}
		xaction=!xaction;
		keyboard_value='x';
		idle();
		break;	
	case 'Y':
		if(keyboard_value=='R')
		{
			break;
		}
		Yaction=!Yaction;
		keyboard_value='Y';
		idle();
		break;		
	case 'Z':
		if(keyboard_value=='R')
		{
			break;
		}
		Zaction=!Zaction;
		keyboard_value='Z';
		idle();
		break;	
	case 'y':
		if(keyboard_value=='R')
		{
			break;
		}
		yaction=!yaction;
		keyboard_value='y';
		idle();
		break;		
	case 'z':
		if(keyboard_value=='R')
		{
			break;
		}
		zaction=!zaction;
		keyboard_value='z';
		idle();
		break;	
    
	case 'R':
		if(keyboard_value=='X'||keyboard_value=='x'||keyboard_value=='Y'||keyboard_value=='y'||keyboard_value=='Z'||keyboard_value=='z')
		{
			break;
		}
		keyboard_value='R';
		rotateaction=!rotateaction;
		idle();
		break;
	case 'B':
		keyboard_value='B';

		idle();
		break;
	case 'm':
		keyboard_value='m';
		normalaction=!normalaction;
		display();
		break;
	case 'e':
		keyboard_value='e';
		boundaction=!boundaction;
		display();
		break;
	}	
}

void idle( void )
{
	
	switch(keyboard_value)
	{
		case'X':
			if(!Xaction){
				stepX += (picture[numclick].xMAX-picture[numclick].xMIN)/5000;
				if ( stepX > (picture[numclick].xMAX-picture[numclick].xMIN) ) {
					//stepX -= (picture[numclick].xMAX-picture[numclick].xMIN);
					display();
					}
				glutPostRedisplay();
			}
		break;

		case 'x':
			if(!xaction){
				stepX -= (picture[numclick].xMAX-picture[numclick].xMIN)/5000;
				if ( stepX < 0.0 ) {
					//stepX += (picture[numclick].xMAX-picture[numclick].xMIN);
					display();
					}
				glutPostRedisplay();
			}
		break;	

		case'Y':
			if(!Yaction){
				stepY += (picture[numclick].yMAX-picture[numclick].yMIN)/5000;
				if ( stepY > (picture[numclick].yMAX-picture[numclick].yMIN) ) {
					//stepY -= (picture[numclick].yMAX-picture[numclick].yMIN);
					display();
					}
				glutPostRedisplay();
			}
		break;

		case 'y':
			if(!yaction){
				stepY -= (picture[numclick].yMAX-picture[numclick].yMIN)/5000;
				if ( stepY < 0.0 ) {
					//stepY += (picture[numclick].yMAX-picture[numclick].yMIN);
					display();
					}
				glutPostRedisplay();
			}
		break;

		case'Z':
			if(!Zaction){
				stepZ += (picture[numclick].zMAX-picture[numclick].zMIN)/5000;
				if ( stepZ > (picture[numclick].zMAX-picture[numclick].zMIN) ) {
					//stepZ -= (picture[numclick].zMAX-picture[numclick].zMIN);
					display();
					}
				glutPostRedisplay();
			}
		break;

		case 'z':
			if(!zaction){
				stepZ -= (picture[numclick].zMAX-picture[numclick].zMIN)/5000;
				if ( stepZ < 0.0 ) {
					//stepZ += (picture[numclick].zMAX-picture[numclick].zMIN);
					display();
					}
				glutPostRedisplay();
			}
		break;

		case 'R':
			if(!rotateaction){
				if(numclick%2==0){
					picture[numclick].thetaY += 0.1;
					if(picture[numclick].thetaY >= 360)
						numclick++;
				}

				else {
					picture[numclick].thetaY -= 0.1;
					if(picture[numclick].thetaY < -360)
						numclick++;
				}
				glutPostRedisplay();

				if(numclick == 2)
					numclick = 0;

			}


		break;

		case 'B':	
			
				
			

			if(!pulsingaction)
			{
				picture[numclick].stepN -= ztrans/10000;
				
			}
			else {
				picture[numclick].stepN += ztrans/10000;
			}

			if( picture[numclick].stepN >= ztrans/10 ){
				pulsingaction =! pulsingaction;
			}
			if(picture[numclick].stepN < 0){

				pulsingaction =! pulsingaction;
			}
			//display();
			glutPostRedisplay();
			break;

	}
	
}

void ReadTxtFile(char *FileName,int numtoken)
{
	
	FILE *inStream;

	char buffer[999];
	if((inStream = fopen(FileName, "rt")) == NULL) // Open The File
	{
		printf("File does not exist!");
		exit(0);
	}

			fgets(buffer,10,inStream);			// txt

			while (  strncmp( "len: ", buffer, 5 ))
			{
				fgets(buffer,10,inStream);			// format
			}
			strcpy(buffer, buffer+strlen("len: "));
			sscanf(buffer,"%d", &element[numtoken].len);
 
			
			while (  strncmp( "iter: ", buffer, 6  ))
			{
				fgets(buffer,10,inStream);			// format
			}
			strcpy(buffer, buffer+strlen("len: "));
			sscanf(buffer,"%d", &element[numtoken].iter);


			while (  strncmp( "rot: ", buffer,5  ))
					{
						fgets(buffer,30,inStream);			// format
					}

			strcpy(buffer, buffer+strlen("rot: "));
			sscanf(buffer,"%f %f %f", &element[numtoken].rotx,&element[numtoken].roty,&element[numtoken].rotz);


			while (  strncmp( "start: ", buffer, 7  ))
					{
						fgets(buffer,10,inStream);			// format
					}
			strcpy(buffer, buffer+strlen("start: "));
			sscanf(buffer,"%s", &element[numtoken].start);


			

			while (  strncmp( "F: ", buffer, 3  ))
					{
						fgets(buffer,35,inStream);			// format
					}
			strcpy(buffer, buffer+strlen("F: "));
			sscanf(buffer,"%s", &element[numtoken].leftstart);
			
		fclose(inStream);

		//copy to R+L system
		element[numtoken].length = strlen(element[numtoken].leftstart);

		element[numtoken].rightsystem = new char[element[numtoken].length+1];
		element[numtoken].leftsystem = new char[element[numtoken].length+1];
		
		for(int i=0; i < element[numtoken].length; i++)
		{
			element[numtoken].rightsystem[i] = element[numtoken].leftstart[i];
		}
		element[numtoken].rightsystem[element[numtoken].length] = '\0';

		doIterate(numtoken,element[numtoken].iter-1);
		
}

void doIterate(int num,int iteratenum)
{
	unsigned int count=0;
	unsigned int i,a;
	unsigned int j=0;
	unsigned int b=0;
	
	element[num].initlength = strlen(element[num].leftstart);
	for(int itime=1; itime <= iteratenum; itime++)
	{
		count=0;
		element[num].length = strlen(element[num].rightsystem);//iterate length

			for( i=0;i < element[num].length;i++)
			{
				if(element[num].rightsystem[i]=='F')
				{
					count++;
				}
			}
			
			element[num].s = element[num].initlength*count+(element[num].length-count);
			size_t s = element[num].s;
			size_t mb = s / 1024 / 1024;
			element[num].leftsystem = (char *)malloc(element[num].s+1);

			//new leftsystem
			for( j = 0 ; j < element[num].s;)
			{
				for(i=0;i< element[num].length;i++)
				{
					if(element[num].rightsystem[i]=='F')
					{
						for(a=0;a < element[num].initlength;a++)
						{
							element[num].leftsystem[j]=element[num].leftstart[a];
							j++;
						}

					}
					else
					{
						element[num].leftsystem[j]=element[num].rightsystem[i];
						j++;
					}
					
				}
				
			}
			element[num].leftsystem[j] = '\0';

			//new rightsystem
			element[num].rightsystem = (char *)malloc(element[num].s+1);

			for( b=0; b < element[num].s; b++ )
			{
				element[num].rightsystem[b]=element[num].leftsystem[b];
				
			}
			element[num].rightsystem[element[num].s] = '\0';
	}
	element[num].length = strlen(element[num].leftsystem);
	Lsysnum = num;
	generatelinetree();
}

struct TurtleState
{
	vec4 currentposition;
	vec4 currentdirection;
	mat4 Direction;
};

void generatelinetree()
{
	std::vector<TurtleState> stateStack;

	vec4 currentdirection;
	mat4 Direction = Angel::identity();
	currentdirection.x = 0.0f;
	currentdirection.y = 1.0f;
	currentdirection.z = 0.0f;
	currentdirection.w = 0.0f;
	//int count= 0;

	for(Lsysnum = 0; Lsysnum < 5; Lsysnum++){
		currentposition = randomPoint(-70.0f,70.0f);

	//currentposition = randomPoint(40.0f);
		//currentposition.x = 30;
		//currentposition.y = 10;
		//currentposition.z = 30;
		//currentposition.w = 1;
	/*	switch (Lsysnum){
			case 0:
				currentposition = randomPoint(-30.0f,30.0f);
				break;
			case 1:
				currentposition = randomPoint(-30.0f,30.0f);
				break;
			case 2:
				currentposition = randomPoint(-30.0f,30.0f);
				break;
			case 3:
				currentposition = randomPoint(-30.0f,30.0f);
				break;
			case 4:
				currentposition = randomPoint(-30.0f,30.0f);
				break;
			}*/

			//pointodraw[0] = Angel::RotateY(90.0f)*currentposition;
			//PointoDraw[0] = Angel::RotateY(90.0f)*currentposition;
			//rotateMat[0] = Angel::RotateY(90.0f) * Direction;
			//Angel::mat4 modelMat = Angel::identity();
			for(int i = 0; i < element[Lsysnum].length; i++ )
			{
		
				if(element[Lsysnum].leftsystem[i] == 'F')
				{
					//cout<<"good"<<endl;
					
			
					//lsys[Lsysnum].tranY = Translate(currentdirection.x*element[Lsysnum].len, currentdirection.y*element[Lsysnum].len, currentdirection.z*element[Lsysnum].len);			
					////modelMat = modelMat *lsys[Lsysnum].tranY;
					//currentposition = lsys[Lsysnum].tranY * currentposition;
					
					PointoDraw[element[Lsysnum].count] = Angel::RotateY(-90.0f) * currentposition ;
					rotateMat[element[Lsysnum].count] = Angel::RotateY(-90.0f)*  Direction ;
					currentposition = currentposition + currentdirection*element[Lsysnum].len;
					element[Lsysnum].count++;
				}
				//else if(element[Lsysnum].leftstart[i] == 'f')
				//{

				//}
				else if(element[Lsysnum].leftsystem[i] == '+')
				{
					lsys[Lsysnum].rotateX = RotateX(element[Lsysnum].rotx);
					//modelMat = modelMat *lsys[Lsysnum].rotateX;
					Direction = RotateX(element[Lsysnum].rotx) * Direction ;
					currentdirection = lsys[Lsysnum].rotateX * currentdirection;
					
				}
				else if(element[Lsysnum].leftsystem[i] == '-')
				{
					lsys[Lsysnum].rotateX = RotateX(-element[Lsysnum].rotx);
					//modelMat = modelMat *lsys[Lsysnum].rotateX;
					Direction = RotateX(-element[Lsysnum].rotx) * Direction ;
					currentdirection = lsys[Lsysnum].rotateX * currentdirection;
				}
				else if(element[Lsysnum].leftsystem[i] == '&')
				{
					lsys[Lsysnum].rotateY = RotateY(element[Lsysnum].roty);
					//modelMat = modelMat *lsys[Lsysnum].rotateX;
					Direction = RotateY(element[Lsysnum].roty) * Direction ;
					currentdirection = lsys[Lsysnum].rotateY * currentdirection;
				}
				else if(element[Lsysnum].leftsystem[i] == '^')
				{
					lsys[Lsysnum].rotateY = RotateY(-element[Lsysnum].roty);
					//modelMat = modelMat *lsys[Lsysnum].rotateX;
					Direction = RotateY(-element[Lsysnum].roty) * Direction ;
					currentdirection = lsys[Lsysnum].rotateY * currentdirection;
				}
				else if(element[Lsysnum].leftsystem[i] == '\\')
				{
					lsys[Lsysnum].rotateZ = RotateZ(element[Lsysnum].rotz);
					//modelMat = modelMat *lsys[Lsysnum].rotateZ;
					Direction =  RotateZ(element[Lsysnum].rotz)  * Direction;
					currentdirection = lsys[Lsysnum].rotateZ*currentdirection;
				}
				else if(element[Lsysnum].leftsystem[i] == '/')
				{
					lsys[Lsysnum].rotateZ = RotateZ(-element[Lsysnum].rotz);
					//modelMat = modelMat *lsys[Lsysnum].rotateZ;
					Direction =  RotateZ(-element[Lsysnum].rotz) * Direction;
					currentdirection = lsys[Lsysnum].rotateZ *currentdirection;
				}
				else if(element[Lsysnum].leftsystem[i] == '|')
				{
					//currentdirection.x = currentdirection.x * -1;
					//currentdirection.y = currentdirection.y * -1;
					//currentdirection.z = currentdirection.z * -1;
					Direction = Direction;
					currentdirection = -currentdirection;
				}
				else if(element[Lsysnum].leftsystem[i] == '[')
				{
					TurtleState s;
					s.currentdirection = currentdirection;
					s.currentposition = currentposition;
					s.Direction = Direction;
					stateStack.push_back(s);
					
				}
				else if(element[Lsysnum].leftsystem[i] == ']')
				{
					TurtleState s;
					s = stateStack.back();
					stateStack.pop_back();
					currentdirection = s.currentdirection;
					currentposition = s.currentposition;
					Direction = s.Direction;
				}
				else
					cout<< "ERROR!"<<endl;

				// save point
		
				/*pointodraw[count].x = currentposition.x;
				pointodraw[count].y = currentposition.y;
				pointodraw[count].z = currentposition.z;
				pointodraw[count].w = currentposition.w;*/

				//pointodraw[i+1] = Angel::RotateY(90.0f) * currentposition;
				
				//pointodir[i+1] =  Angel::RotateY(90.0f) * Direction;


		
			}
	}
	//cout<<count<<endl;
}

void ReadPlyFile(char *FileName,int i)
{
	
	FILE *inStream;
	GLfloat	x, y, z;
	int triangle_index = 0;
	char buffer[999999];
	if((inStream = fopen(FileName, "rt")) == NULL) // Open The File
	{
		printf("File does not exist!");
		exit(0);
	}

			fgets(buffer,300,inStream);			// ply

			while (  strncmp( "element vertex", buffer,strlen("element face")) != 0  )
			{
				fgets(buffer,300,inStream);			// format
			}
			strcpy(buffer, buffer+strlen("element vertex"));
			sscanf(buffer,"%i", &picture[i].numvertex);
 
			
			while (  strncmp( "element face", buffer,strlen("element face")) != 0  )
			{
				fgets(buffer,300,inStream);			// format
			}
			strcpy(buffer, buffer+strlen("element face"));
			sscanf(buffer,"%i", &picture[i].numface);

			
 
				// go to end_header
			while (  strncmp( "end_header", buffer,strlen("end_header")) != 0  )
					{
						fgets(buffer,300,inStream);			// format
					}

			picture[i].Vertex_Buffer = new float[picture[i].numvertex*3];
			picture[i].Faces_Triangles = new int[picture[i].numface*3];
			picture[i].Normals = new float[picture[i].numface*6];			
			picture[i].currentNormal = new float[picture[i].numface*3];
			// read vertexs
			for (int iterator = 0; iterator < picture[i].numvertex; iterator++)
			{
				fgets(buffer,300,inStream);
				
				sscanf(buffer,"%f %f %f", &picture[i].Vertex_Buffer[iterator*3], &picture[i].Vertex_Buffer[iterator*3+1], &picture[i].Vertex_Buffer[iterator*3+2]);


				if(picture[i].Vertex_Buffer[iterator*3]>=picture[i].xMAX){
					picture[i].xMAX=picture[i].Vertex_Buffer[iterator*3];
					}
				if(picture[i].Vertex_Buffer[iterator*3]<picture[i].xMIN){
					picture[i].xMIN=picture[i].Vertex_Buffer[iterator*3];
				}
				if(picture[i].Vertex_Buffer[iterator*3+1]>=picture[i].yMAX){
					picture[i].yMAX=picture[i].Vertex_Buffer[iterator*3+1];
				}
				if(picture[i].Vertex_Buffer[iterator*3+1]<picture[i].yMIN){
					picture[i].yMIN=picture[i].Vertex_Buffer[iterator*3+1];
				}
				if(picture[i].Vertex_Buffer[iterator*3+2]>=picture[i].zMAX){
					picture[i].zMAX=picture[i].Vertex_Buffer[iterator*3+2];
				}
				if(picture[i].Vertex_Buffer[iterator*3+2]<picture[i].zMIN){
					picture[i].zMIN=picture[i].Vertex_Buffer[iterator*3+2];
				}				
			}

	
		//cout<<picture[i].xMAX<<","<<picture[i].xMIN<<endl;	
		//cout<<picture[i].yMAX<<","<<picture[i].yMIN<<endl;
		//cout<<picture[i].zMAX<<","<<picture[i].zMIN<<endl;

		Angel::mat4 modelMat = Angel::identity();
		//modelMat = modelMat *Angel::Translate(-(picture[i].xMAX + picture[i].xMIN)/2,-(picture[i].yMAX + picture[i].yMIN)/2,-(picture[i].zMAX + picture[i].zMIN)/2);
			//modelMat = modelMat* Angel::RotateX(90.0f);	
		//	modelMat = modelMat* Angel::Scale(0.1,0.1,0.1)*Angel::RotateX(90.0f) *Angel::Translate(-(picture[i].xMAX + picture[i].xMIN)/2,-(picture[i].yMAX + picture[i].yMIN)/2,-(picture[i].zMAX + picture[i].zMIN)/2) ;//* Angel::RotateX(90.0f)
		
		/*if( i==0 )
			modelMat = modelMat* Angel::Scale(1/(picture[i].yMAX-picture[i].yMIN)/20,1/(picture[i].yMAX-picture[i].yMIN),(picture[i].yMAX-picture[i].yMIN)/10)* Angel::RotateX(90.0f) *	Angel::Translate(0,(picture[i].yMAX-picture[i].yMIN)/2,0);
		else modelMat = modelMat* Angel::Scale(1/(picture[i].yMAX-picture[i].yMIN)/20,1/(picture[i].yMAX-picture[i].yMIN)/20,(picture[i].yMAX-picture[i].yMIN)/10);*/
		
			//modelMat = modelMat* Angel::Translate(0,(picture[i].yMAX-picture[i].yMIN)/2,0)* Angel::RotateX(90.0f)* Angel::Scale(1/(picture[i].yMAX-picture[i].yMIN)/20,1/(picture[i].yMAX-picture[i].yMIN),(picture[i].yMAX-picture[i].yMIN)/10);	
		if (i == 0)     //sphere
			modelMat = modelMat* Angel::Scale((picture[0].xMAX-picture[0].xMIN)/20,(picture[i].yMAX-picture[i].yMIN)/20,(picture[i].zMAX-picture[i].zMIN)/20);
		else if( i == 1 )  //cylinder
			modelMat = modelMat* Angel::Translate(0,(picture[i].yMAX-picture[i].yMIN)/5,0)* Angel::RotateX(90.0f)* Angel::Scale((picture[0].xMAX-picture[0].xMIN)/(picture[i].xMAX-picture[i].xMIN),(picture[0].yMAX-picture[0].yMIN)/(picture[i].yMAX-picture[i].yMIN),1/(picture[i].zMAX-picture[i].zMIN));	
			
		for(int iterator = 0; iterator < picture[i].numvertex; iterator++){
			Angel::vec4 modelvertex(
			picture[i].Vertex_Buffer[iterator*3],
			picture[i].Vertex_Buffer[iterator*3+1],
			picture[i].Vertex_Buffer[iterator*3+2],
			1.0
			);
			modelvertex=modelMat*modelvertex;
			
			picture[i].Vertex_Buffer[iterator*3] = modelvertex.x;
			picture[i].Vertex_Buffer[iterator*3+1] = modelvertex.y;
			picture[i].Vertex_Buffer[iterator*3+2] = modelvertex.z;
		}

		picture[i].xMAX=0;
		picture[i].xMIN=0;
		picture[i].yMAX=0;
		picture[i].yMIN=0;
		picture[i].zMAX=0;
		picture[i].zMIN=0;
		

		for (int iterator = 0; iterator < picture[i].numvertex; iterator++)
			{
				if(picture[i].Vertex_Buffer[iterator*3]>=picture[i].xMAX){
					picture[i].xMAX=picture[i].Vertex_Buffer[iterator*3];
					}
				if(picture[i].Vertex_Buffer[iterator*3]<picture[i].xMIN){
					picture[i].xMIN=picture[i].Vertex_Buffer[iterator*3];
				}
				if(picture[i].Vertex_Buffer[iterator*3+1]>=picture[i].yMAX){
					picture[i].yMAX=picture[i].Vertex_Buffer[iterator*3+1];
				}
				if(picture[i].Vertex_Buffer[iterator*3+1]<picture[i].yMIN){
					picture[i].yMIN=picture[i].Vertex_Buffer[iterator*3+1];
				}
				if(picture[i].Vertex_Buffer[iterator*3+2]>=picture[i].zMAX){
					picture[i].zMAX=picture[i].Vertex_Buffer[iterator*3+2];
				}
				if(picture[i].Vertex_Buffer[iterator*3+2]<picture[i].zMIN){
					picture[i].zMIN=picture[i].Vertex_Buffer[iterator*3+2];
				}
				
			}


		

			// read faces

			for (int iterator = 0; iterator < picture[i].numface; iterator++)
			{
				fgets(buffer,300,inStream);
 
					if (buffer[0] == '3')
					{
 						int vertex1 = 0, vertex2 = 0, vertex3 = 0;
						buffer[0] = ' ';
						sscanf(buffer,"%i%i%i", &vertex1, &vertex2, &vertex3 );

						picture[i].Faces_Triangles[iterator*3    ] = vertex1;
						picture[i].Faces_Triangles[iterator*3 + 1] = vertex2;
						picture[i].Faces_Triangles[iterator*3 + 2] = vertex3;
					

						//collect every three points of triangle into Normal to be calculated

						float coord1[3] = {picture[i].Vertex_Buffer[vertex1*3], picture[i].Vertex_Buffer[vertex1*3+1], picture[i].Vertex_Buffer[vertex1*3+2]};
						float coord2[3] = {picture[i].Vertex_Buffer[vertex2*3], picture[i].Vertex_Buffer[vertex2*3+1], picture[i].Vertex_Buffer[vertex2*3+2]};
						float coord3[3] = {picture[i].Vertex_Buffer[vertex3*3], picture[i].Vertex_Buffer[vertex3*3+1], picture[i].Vertex_Buffer[vertex3*3+2]};
						

						/* calculate Vector1 and Vector2 */
						   float va[3], vb[3], val;
						   //float vr[3];
						   va[0] = coord1[0] - coord2[0];
						   va[1] = coord1[1] - coord2[1];
						   va[2] = coord1[2] - coord2[2];

						  vec3 normpoint1 = (0.0,0.0,0.0);
						  normpoint1.x = va[0];
						  normpoint1.y = va[1];
						  normpoint1.z = va[2];

						   vb[0] = coord1[0] - coord3[0];
						   vb[1] = coord1[1] - coord3[1];
						   vb[2] = coord1[2] - coord3[2];

						  vec3 normpoint2 = (0.0,0.0,0.0);
						  normpoint2.x = vb[0];
						  normpoint2.y = vb[1];
						  normpoint2.z = vb[2];

						/* cross product */

						vec3 normals=(0.0,0.0,0.0);
						normals = cross(normpoint1,normpoint2);
						normals = normalize(normals);
						picture[i].vr[0]=normals.x;
						picture[i].vr[1]=normals.y;
						picture[i].vr[2]=normals.z;

						picture[i].currentNormal[iterator*3] = normals.x;
						picture[i].currentNormal[iterator*3+1] = normals.y;
						picture[i].currentNormal[iterator*3+2] = normals.z;

	
						picture[i].Normals[iterator*6]  = (coord1[0]+coord2[0]+coord3[0])/3;
						picture[i].Normals[iterator*6+1] = (coord1[1]+coord2[1]+coord3[1])/3;
						picture[i].Normals[iterator*6+2] = (coord1[2]+coord2[2]+coord3[2])/3;

						picture[i].Normals[iterator*6+3] = picture[i].Normals[iterator*6]+normals.x;	
						picture[i].Normals[iterator*6+4] = picture[i].Normals[iterator*6+1]+normals.y;	
						picture[i].Normals[iterator*6+5] = picture[i].Normals[iterator*6+2]+normals.z;
					

					}				
			}
		
		// Create VBO.
		//GLuint m_VBO; 
		glGenBuffers( 1, &picture[i].m_VBO );
		glBindBuffer( GL_ARRAY_BUFFER, picture[i].m_VBO );
		glBufferData( GL_ARRAY_BUFFER, sizeof(float)*picture[i].numvertex*3, picture[i].Vertex_Buffer, GL_STATIC_DRAW );

		//create IBO
		//GLuint m_IBO; 
		glGenBuffers( 1, &picture[i].m_IBO );
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,  picture[i].m_IBO );
		glBufferData( GL_ELEMENT_ARRAY_BUFFER, sizeof(int)*picture[i].numface*3, picture[i].Faces_Triangles, GL_STATIC_DRAW );
		fclose(inStream);
}

int main( int argc, char **argv )
{
	// init glut
    glutInit( &argc, argv );
    glutInitDisplayMode( GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH );
    glutInitWindowSize( 800,800 );
	width = 512;
	height = 512;


    glutInitContextVersion( 3, 1 );
    glutInitContextProfile( GLUT_CORE_PROFILE );

	// create window
	// opengl can be incorperated into other packages like wxwidgets, fltoolkit, etc.
    glutCreateWindow( "Color Cube" );
	ReadTxtFile("lsys1.txt",0);
	ReadTxtFile("lsys2.txt",1);
	ReadTxtFile("lsys3.txt",2);
	ReadTxtFile("lsys4.txt",3);
	ReadTxtFile("lsys5.txt",4);
	
	// init glew
    glewInit();
	ReadPlyFile("sphere.ply",0);
	ReadPlyFile("cylinder.ply",1);
	/*ReadPlyFile("weathervane.ply",0);
	ReadPlyFile("airplane.ply",1);
	ReadPlyFile("ant.ply",2);
	ReadPlyFile("apple.ply",3);
	ReadPlyFile("balance.ply",4);
	ReadPlyFile("beethoven.ply",5);
	ReadPlyFile("big_atc.ply",6);
	ReadPlyFile("big_dodge.ply",7);
	ReadPlyFile("teapot.ply",8);
	ReadPlyFile("big_porsche.ply",9);
	ReadPlyFile("big_spider.ply",10);
	ReadPlyFile("canstick.ply",11);
	ReadPlyFile("chopper.ply",12);
	ReadPlyFile("cow.ply",13);
	ReadPlyFile("dolphins.ply",14);
	ReadPlyFile("egret.ply",15);
	ReadPlyFile("f16.ply",16);
	ReadPlyFile("footbones.ply",17);
	ReadPlyFile("fracttree.ply",18);
	ReadPlyFile("galleon.ply",19);
	ReadPlyFile("hammerhead.ply",20);
	ReadPlyFile("helix.ply",21);
	ReadPlyFile("hind.ply",22);
	ReadPlyFile("kerolamp.ply",23);
	ReadPlyFile("ketchup.ply",24);
	ReadPlyFile("mug.ply",25);
	ReadPlyFile("part.ply",26);
	ReadPlyFile("pickup_big.ply",27);
	ReadPlyFile("pump.ply",28);
	ReadPlyFile("pumpa_tb.ply",29);
	ReadPlyFile("sandal.ply",30);
	ReadPlyFile("saratoga.ply",31);
	ReadPlyFile("scissors.ply",32);
	ReadPlyFile("shark.ply",33);
	ReadPlyFile("steeringweel.ply",34);
	ReadPlyFile("stratocaster.ply",35);
	ReadPlyFile("street_lamp.ply",36);
	ReadPlyFile("tennis_shoe.ply",37);
	ReadPlyFile("tommygun.ply",38);
	ReadPlyFile("trashcan.ply",39);
	ReadPlyFile("turbine.ply",40);
	ReadPlyFile("urn2.ply",41);
	ReadPlyFile("walkman.ply",42);*/



    generateGeometry();

	// assign handlers
	glutKeyboardFunc( keyboard );
    glutDisplayFunc( display );
	glutIdleFunc(idle);
    glutMainLoop();
	return 0;
}
